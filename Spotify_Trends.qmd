---
title: Spotify Trends
author: Markus Janke <br> Tim Beyer
editor: visual
lang: de
format:
  html:
    theme: zephyr
---

# Quellenangaben

hier Datensatzquelle einfügen

# 1 Vorbereitung

### 1.1 Pakete laden

```{r, message=FALSE}
library(tidyverse)
library(tidymodels)
library(randomForest)
library(rpart.plot)
library(dials)
library(explore)
library(ggplot2)
```

### 1.2 Arbeitsumgebung festlegen

```{r}
setwd(".")  # Arbeitsverzeichnis setzen
getwd()     # Arbeitsverzeichnis ausgeben

```

### 1.3 Daten einlesen

```{r}
dataset <- read_csv("spotify-2023.csv")
```

# 2 Überblick über die Daten

### 2.1 Dimensionen des Datensatzes

```{r}
dim(dataset)
```

### 2.2 Struktur des Datensatzes

```{r}
describe_tbl(dataset)
```

### 2.3 Spaltennamen des Datensatzes

```{r}
colnames(dataset)
```

### 2.4 Zusammenfassung für jede Spalte anzeigen

```{r}
summary(dataset)
```

# 3 Bereinigung der Daten

### 3.1 Bearbeiten der Spalte streams, sodass diese als numerischer Wert interpretiert wird

Die Zusammenfassung der Spalten zeigt, dass "streams" als character erkannt wurde, da dieser Wert jedoch numerisch ist sollte dieser auch als solcher interpretiert werden.

```{r}
dataset$streams <- as.numeric(dataset$streams)
```

### 3.2 Löschen des Datensatzes ohne eintrag in streams

Durch die Umwandlung von character zu numeric wurden NAs erzeugt, dieser Datensatz wird gelöscht, da Streams die für die genaue Betrachtung relevanteste Spalte ist und ohne diese Spalte keine qualitativen Aussagen getroffen werden können. Des Weiteren betrifft dies nur einen Wert, wodurch die Datenmenge nicht signifikant verkleinert wird.

```{r}
dataset <- dataset[!is.na(dataset$streams), ]
```

### 3.3 Löschen der Spalte in_shazam_charts

Darüber hinaus sind in der Spalte "in_shazam_charts" einige NAs enthalten. Dies kann darauf zurückzuführen sein, dass die entsprechenden Songs nicht auf Shazam verfügbar sind oder dass Shazam nicht die Rechte für das Abspielen des Songs hat. Da Shazam insgesamt ein nicht sehr beliebter Musikstreamingsienst ist, wird diese Spalte entfernt, da sie für die weitere Betrachtung nicht relevant ist.

```{r}
dataset$in_shazam_charts <- NULL
```

### 3.4 Löschen der Spalte key:

In der Spalte "key" sind etwa 10% der Werte NAs. Da diese Spalte dadurch nicht aussagekräftig ist, wird diese ebenfalls entfernt.

```{r}
dataset$key <- NULL
```

### 3.5 Umbennen der Spalten, die ein "%" enthalten

Die Spalten "danceability", "energy", "speechiness", "acousticness", "instrumentalness", "liveness"und "valence" enthalten ein "%". Dies kann zu Problemen bei der weiteren Verarbeitung führen, weshalb diese Spalten umbenannt werden.

```{r}
colnames(dataset)[colnames(dataset) == "danceability_%"] <- "danceability_percent"
colnames(dataset)[colnames(dataset) == "energy_%"] <- "energy_percent"
colnames(dataset)[colnames(dataset) == "speechiness_%"] <- "speechiness_percent"
colnames(dataset)[colnames(dataset) == "acousticness_%"] <- "acousticness_percent"
colnames(dataset)[colnames(dataset) == "instrumentalness_%"] <- "instrumentalness_percent"
colnames(dataset)[colnames(dataset) == "liveness_%"] <- "liveness_percent"
colnames(dataset)[colnames(dataset) == "valence_%"] <- "valence_percent"
```

### 3.6 Zusammenfassung des bereinigten Datensatzes

```{r}
summary(dataset)
```

# 4 Beliebtheitsscore berechnen

Um die Beliebheit der Songs über mehrere Werte beurteilen zu können, wird ein Beliebheitsscore berechnet. Dieser setzt sich aus den Streams und den Charts der verschiedenen Streamingdienste zusammen.

### 4.1 Gewichtungen

Die Gewichtung der einzelnen Werte, die in die Bewertung des Beliebtheitsscores einfließen, ergibt sich aus der Beliebtheit der verschiedenen Streamingdienste. Spotify ist der größte Streamingdienst und wird deshalb am stärksten gewichtet. Die anderen Streamingdienste werden entsprechend ihrer Beliebtheit gewichtet. Apple Music ist nach Spotify einer der beliebtesten Streamingdienste und wird deshalb am zweitstärksten gewichtet. Deezer ist in Untersuchungen sehr weit hinter Spotify und Apple, was in der Gewichtung deutlich wird. Orientiert wurde sich hierbei an der Studie von Statista, welche Musikstreamingdienste weltweit am häufigsten genutzt werden. (https://www.statista.com/chart/20826/music-streaming-services-with-most-subscribers-global-fipp/) In der Statistik sind mehr Streamingdienste zu sehen als hier untersucht werden, dies liegt daran, dass diese nicht erfasst wurden oder, dass kein Zugriff auf die Daten besteht und diese somit nicht aufgenommen werden konnten. Genauer wird darauf noch im Ausblick und in den Grenzen des Projekts eingegangen.

```{r}
w_streams <- 1
w_spotify_charts <- -2  
w_deezer_charts <- -1.5
w_apple_charts <- -1.3
```

### 4.2 Berechnung des Beliebheitsscores

Bie der Berechnung des Beliebtheitssscores wird zunächst der ursprüngliche Wert der einzelnen Spalten mit der entsprechenden Gewichtung multipliziert. Anschließend werden die einzelnen Werte addiert und durch die Anzahl der Spalten geteilt, um den Durchschnitt zu erhalten.

```{r}
dataset$popularity_score <- (
  w_streams * dataset$streams +
  w_spotify_charts * dataset$in_spotify_charts +
  w_deezer_charts * dataset$in_deezer_charts +
  w_apple_charts * dataset$in_apple_charts
) / sum(!is.na(dataset[, c("streams", "in_spotify_charts", "in_deezer_charts", "in_apple_charts")]))
```

# 5 Thesen

### 5.1 Die Veröffentlichung im Sommer führt zu höheren Streamzahlen (Tim)

Die These stellt die Vermutung auf, dass die Veröffentlichung im Sommer zu höheren Streamzahlen führt. Dies könnte daran leigen, dass im Sommer veröffentlichte Songs oft ein Sommerhit werden könnten und somit häufiger gestreamt werden. Außerdem vermitteln Songs die im Sommer veröffentlicht werden, häufig ein sommerliches Gefühl, wodurch diese Songs auch ganzjährig häufiger gestreamt werden.

Um diese These zu überprüfen, wird zunächst der Durchschnitt der Streams im Sommer berechnet. Anschließend wird der Durchschnitt der Streams in anderen Jahreszeiten berechnet. Diese beiden Werte werden anschließend miteinander verglichen und in einem Balkendiagramm graphisch gegenüber gestellt.

#### 5.1.1 Durchschnittliche Streams im Sommer

```{r}
mean_streams_summer <- mean(dataset$streams[dataset$released_month %in% c(6, 7, 8)])
```

#### 5.1.2 Durchschnittliche Streams im Sommer

```{r}
mean_streams_other_seasons <- mean(dataset$streams[dataset$released_month %in% c(1, 2, 3, 4, 5, 9, 10, 11, 12)])
```

#### 5.1.3 Vergleich der beiden Werte

```{r}
mean_streams_summer / mean_streams_other_seasons
```

Aus diesem Wert lässt sich erkenne, dass die Stream im Sommer im Durchschnitt unter den Streams in anderen Jahreszeiten liegen. Dies spricht gegen die These, dass die Veröffentlichung im Sommer zu höheren Streamzahlen führt. Deshlab schauen wir uns die Werte im folgenden genauer an.

```{r}
mean_streams_summer
mean_streams_other_seasons
```

Die Werte der anderen Jahreszeiten sind etwa 50.000 Streams höher als die Werte der im Sommer veröffentlichten Songs.Um den Unterschied einmal graphisch darzustellen, wird ein Balkendiagramm erstellt.

#### 5.1.5 Daten für das Balkendiagramm vorbereiten

```{r}
bar_data <- data.frame(
  Season = c("Sommer", "Andere Jahreszeiten"),
  Mean_Streams = c(mean_streams_summer, mean_streams_other_seasons)
)
```

#### 5.1.6 Balkendiagramm über die durchschnittlichen Streams im Sommer vs. andere Jahreszeiten erstellen

```{r}
ggplot(bar_data, aes(x = Season, y = Mean_Streams, fill = Season)) +
  geom_bar(stat = "identity", position = "dodge", width = 0.7, color = "black") +
  labs(title = "Durchschnittliche Streamzahlen im Sommer vs. andere Jahreszeiten",
       x = "Jahreszeit",
       y = "Durchschnittliche Streams") +
  theme_minimal()+
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_y_continuous(labels = scales::comma)
```

Im Balkendiagramm lässt sich erkennen, dass die Stream im Sommer im Durchschnitt unter den Streams in anderen Jahreszeiten liegen. Dies spricht wie oben erwähnt gegen die aufgestellte These. Jedoch ist zu bemerken, dass der Unterschied nicht sehr groß ist. Die Streamzahlen im Sommer sind nur etwa 50.000 Streams niedriger als die Streamzahlen in anderen Jahreszeiten. Dies ist ein Unterschied von etwa 1,5%. Dieser Unterschied ist nicht sehr groß und könnte auch durch Zufall entstanden sein. Deshalb wird im folgenden noch einmal genauer auf die Streamzahlen in den einzelnen Monaten geschaut.

#### 5.1.7 Durschschnittliche Streams über die verschiedenen Monate berechnen

```{r}
mean_streams_january <- mean(dataset$streams[dataset$released_month %in% c(1)])
mean_streams_february <- mean(dataset$streams[dataset$released_month %in% c(2)])
mean_streams_march <- mean(dataset$streams[dataset$released_month %in% c(3)])
mean_streams_april <- mean(dataset$streams[dataset$released_month %in% c(4)])
mean_streams_may <- mean(dataset$streams[dataset$released_month %in% c(5)])
mean_streams_june <- mean(dataset$streams[dataset$released_month %in% c(6)])
mean_streams_july <- mean(dataset$streams[dataset$released_month %in% c(7)])
mean_streams_august <- mean(dataset$streams[dataset$released_month %in% c(8)])
mean_streams_september <- mean(dataset$streams[dataset$released_month %in% c(9)])
mean_streams_october <- mean(dataset$streams[dataset$released_month %in% c(10)])
mean_streams_november <- mean(dataset$streams[dataset$released_month %in% c(11)])
mean_streams_dezember <- mean(dataset$streams[dataset$released_month %in% c(12)])
```

#### 5.1.8 Daten für das Balkendiagramm vorbereiten

```{r}
bar_data_months <- data.frame(
  Month = c("January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "Dezember"),
  Mean_Streams = c(mean_streams_january, mean_streams_february, mean_streams_march, mean_streams_april, mean_streams_may, mean_streams_june, mean_streams_july, mean_streams_august, mean_streams_september, mean_streams_october, mean_streams_november, mean_streams_dezember)
)
```

#### 5.1.9 chronologische Ordnung der Daten

```{r}
bar_data_months$Month <- factor(bar_data_months$Month, levels = c("January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "Dezember"))
```

#### 5.1.10 Balkendiagramm erstellen über die durchschnittlichen Streams über die verschiedenen Monate

```{r}
ggplot(bar_data_months, aes(x = Month, y = Mean_Streams, fill = Month)) +
  geom_bar(stat = "identity", position = "dodge", width = 0.7, color = "black") +
  labs(title = "Durchschnittliche Streamzahlen über die verschiedenen Monate",
       x = "Monat",
       y = "Durchschnittliche Streams") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_y_continuous(labels = scales::comma)

```

An den durchschnittlichen Streamzahlen über die verschiedenen Monate lässt sich erkenne, dass die Sommermonate, Verhältnismäßig zu den anderen Monaten, nicht die höchsten Streamzahlen haben. Die höchsten Streamzahlen haben die Monate September, Januar und August. Generell lässt sich erkennen, dass die Streams ab Juli ansteigen und nach dem September bis zum Dezember wieder abfallen. Das könnte darauf zurückzuführen sein, dass die Songs die in den Herbstmonaten veröffentlichen veröffentlichen in der dunkleren Jahreszeit ein Gefühl von Wärme und Geborgenheit geben, nach welchem sich Menschen dann das ganze Jahr über sehnen und diese Songs aus diesem Grund ganzjährig beliebt sind. Diese These wird im folgenden noch einmal genauer untersucht.

### 5.2 Je beliebter ein Song ist, desto besser lässt sich zu ihm Tanzen (Tim)

Die These stellt die Vermutung auf, dass sich ein song besser tanzen eignet, wenn er beliebt ist. Die These wurde mit dem Hintergrund aufgestellt, das Songs die in Diskotheken gespielt werden, meistens sehr beliebt sind und sich gut zum Tanzen eignen. Um diese These zu überprüfen, wird im folgenden ein Scatterplot erstellt, der die Beliebtheit eines Songs mit der Tanzbarkeit des Songs vergleicht.

#### 5.2.1 Scatterplot erstellen

```{r}
ggplot(dataset, aes(x = popularity_score, y = danceability_percent)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE, color = "turquoise") +
  labs(title = "Beliebtheit eines Songs im Vergleich zur Tanzbarkeit",
       x = "Beliebtheit",
       y = "Tanzbarkeit") +
  theme_minimal() +
  scale_y_continuous(labels = scales::comma)
```

#### 5.2.2 Korrelationskoeffizient berechnen

```{r}
cor(dataset$popularity_score, dataset$danceability_percent)
```

Aus der linearen Regression lässt sich kein Zusammenhang zwischen den beiden Werten erkennen. Dies wird auch durch den Korrelationskoeffizienten bestätigt, der nahe 0 ist belegt. Die These kann somit nicht bestätigt werden und die Beliebtheit eines Songs hat keinen Einfluss auf die Tanzbarkeit des Songs.

# 6 Machine Learning Modelle

### 6.1 Regression

z-Standardisieren

```{r}
cols_to_scale <- colnames(dataset |>  dplyr::select(popularity_score))
dataset_scale <- dataset |> mutate_at(cols_to_scale, ~(scale(.) |>  as.vector()))
```

Aufteilung in Trainings- und Testset

```{r}
set.seed(2023)
dataset_split <- initial_split(dataset_scale, prop = 0.8, strata = popularity_score)
dataset_train <- training(dataset_split)
dataset_test  <- testing(dataset_split)
```

Auswählen der relevanten Spalten

```{r}
relevant_cols <- c("popularity_score", "danceability_percent", "energy_percent", "speechiness_percent", "acousticness_percent", "instrumentalness_percent", "liveness_percent", "valence_percent")
dataset_train <- dataset_train %>% select(popularity_score, relevant_cols)
dataset_test <- dataset_test %>% select(popularity_score, relevant_cols)

```

Modell initialisieren:

```{r}
mlp_dataset_mod <- 
    mlp() |>  
    set_mode("regression") |> 
    set_engine("nnet")
```

Modell trainieren:

```{r}
mlp_dataset_fit <- 
    mlp_dataset_mod |> 
    fit(popularity_score ~ ., data = dataset_train)
```

Vorhersage auf den Testdaten:

```{r}
pred <- predict(mlp_dataset_fit, dataset_test)
results <- dataset_test |>  dplyr::select(popularity_score) %>% bind_cols(pred)
```

```{r}
rmse(data = results, truth = popularity_score, estimate = .pred)
```

# 7 Grenzen des Projekts

# 8 Ausblick

# Quellenverzeichnis

# Ehrenwörtliche Erklärung

Hiermit erkläre ich, dass ich die vorliegende Studienarbeit selbständig angefertigt habe. Es wurden nur die in der Arbeit ausdrücklich benannten Quellen und Hilfsmittel benutzt. Wörtlich oder sinngemäß übernommenes Gedankengut habe ich als solches kenntlich gemacht. Diese Arbeit hat in gleicher oder ähnlicher Form ganz oder teilweise noch keiner Prüfungsbehörde vorgelegen.

Unterschriften einfügen
