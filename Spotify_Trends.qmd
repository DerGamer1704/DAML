---
title: "Spotify Trends"
author: "Markus Janke, Tim Beyer"
format: html
editor: visual
---

# Quellenangaben

hier Datensatzquelle einfügen

# Pakete laden

```{r, message=FALSE}
library(tidyverse)
library(tidymodels)
library(randomForest)
library(rpart.plot)
library(dials)
library(explore)
library(ggplot2)
```

# Arbeitsumgebung

Arbeitsverzeichnis setzen

```{r}
setwd(".")  # Arbeitsverzeichnis setzen
getwd()     # Arbeitsverzeichnis ausgeben

```

# Daten einlesen

```{r}
dataset <- read_csv("spotify-2023.csv")
```

# Daten einsehen

Dimensionen anzeigen

```{r}
dim(dataset)
```

Struktur anzeigen

```{r}
describe_tbl(dataset)
```

```{r}
describe(dataset)
```

Spaltennamen anzeigen

```{r}
colnames(dataset)
```

Zusammenfassung für jede Spalte anzeigen

```{r}
summary(dataset)
```

# 2 Bereinigung der Daten

### 2.1 Bearbeiten der Spalte streams, sodass diese als numerischer Wert interpretiert wird

Die Zusammenfassung der Spalten zeigt, dass "streams" als character erkannt wurde, da dieser Wert jedoch numerisch ist sollte dieser auch als solcher interpretiert werden.

```{r}
dataset$streams <- as.numeric(dataset$streams)
```

### 2.2 Löschen des Datensatzes ohne eintrag in streams

Durch die Umwandlung von character zu numeric wurden NAs erzeugt, dieser Datensatz wird gelöscht, da Streams die für die genaue Betrachtung relevanteste Spalte ist und ohne diese Spalte keine qualitativen Aussagen getroffen werden können. Des Weiteren betrifft dies nur einen Wert, wodurch die Datenmenge nicht signifikant verkleinert wird.

```{r}
dataset <- dataset[!is.na(dataset$streams), ]
```

### 2.3 Löschen der Spalte in_shazam_charts

Darüber hinaus sind in der Spalte "in_shazam_charts" einige NAs enthalten. Dies kann darauf zurückzuführen sein, dass die entsprechenden Songs nicht auf Shazam verfügbar sind oder dass Shazam nicht die Rechte für das Abspielen des Songs hat. Da Shazam insgesamt ein nicht sehr beliebter Musikstreamingsienst ist, wird diese Spalte entfernt, da sie für die weitere Betrachtung nicht relevant ist.

```{r}
dataset$in_shazam_charts <- NULL
```

### 2.4 Löschen der Spalte key:

In der Spalte "key" sind etwa 10% der Werte NAs. Da diese Spalte dadurch nicht aussagekräftig ist, wird diese ebenfalls entfernt.

```{r}
dataset$key <- NULL
```

### 2.5 Umbennen der Spalten, die ein "%" enthalten

Die Spalten "danceability", "energy", "loudness", "speechiness", "acousticness", "instrumentalness", "liveness", "valence" und "tempo" enthalten ein "%". Dies kann zu Problemen bei der weiteren Verarbeitung führen, weshalb diese Spalten umbenannt werden.

```{r}
colnames(dataset)[colnames(dataset) == "danceability_%"] <- "danceability_percent"
colnames(dataset)[colnames(dataset) == "energy_%"] <- "energy_percent"
colnames(dataset)[colnames(dataset) == "loudness_%"] <- "loudness_percent"
colnames(dataset)[colnames(dataset) == "speechiness_%"] <- "speechiness_percent"
colnames(dataset)[colnames(dataset) == "acousticness_%"] <- "acousticness_percent"
colnames(dataset)[colnames(dataset) == "instrumentalness_%"] <- "instrumentalness_percent"
colnames(dataset)[colnames(dataset) == "liveness_%"] <- "liveness_percent"
colnames(dataset)[colnames(dataset) == "valence_%"] <- "valence_percent"
colnames(dataset)[colnames(dataset) == "tempo_%"] <- "tempo_percent"
```


### 2.5 Zusammenfassung des bereinigten Datensatzes

```{r}
summary(dataset)
```

# 3 Beliebtheitsscore berechnen

Um die Beliebheit der Songs über mehrere Werte beurteilen zu können, wird ein Beliebheitsscore berechnet. Dieser setzt sich aus den Streams und den Charts der verschiedenen Streamingdienste zusammen.

### 3.1 Gewichtungen

Die Gewichtung der einzelnen Werte, die in die Bewertung des Beliebtheitsscores einfließen, ergibt sich aus der Beliebtheit der verschiedenen Streamingdienste. Spotify ist der größte Streamingdienst und wird deshalb am stärksten gewichtet. Die anderen Streamingdienste werden entsprechend ihrer Beliebtheit gewichtet. Apple Music ist nach Spotify einer der beliebtesten Streamingdienste und wird deshalb am zweitstärksten gewichtet. Deezer ist in Untersuchungen sehr weit hinter Spotify und Apple, was in der Gewichtung deutlich wird. Orientiert wurde sich hierbei an der Studie von Statista, welche Musikstreamingdienste weltweit am häufigsten genutzt werden. (https://de.statista.com/statistik/daten/studie/1102371/umfrage/marktanteile-der-groessten-musik-streaming-dienste-weltweit/)

```{r}
w_streams <- 1
w_spotify_charts <- -2  
w_deezer_charts <- -1.5
w_apple_charts <- -1.3
```

### 3.2 Berechnung des Beliebheitsscores

Bie der Berechnung des Beliebtheitssscores wird zunächst der ursprüngliche Wert der einzelnen Spalten mit der entsprechenden Gewichtung multipliziert. Anschließend werden die einzelnen Werte addiert und durch die Anzahl der Spalten geteilt, um den Durchschnitt zu erhalten.

```{r}
dataset$popularity_score <- (
  w_streams * dataset$streams +
  w_spotify_charts * dataset$in_spotify_charts +
  w_deezer_charts * dataset$in_deezer_charts +
  w_apple_charts * dataset$in_apple_charts
) / sum(!is.na(dataset[, c("streams", "in_spotify_charts", "in_deezer_charts", "in_apple_charts")]))
```

# 4 Thesen

### 4.1 Die Veröffentlichung im Sommer führt zu höheren Streamzahlen

```{r}
# Durchschnittliche Streams im Sommer
mean_streams_summer <- mean(dataset$streams[dataset$released_month %in% c(6, 7, 8)])

# Durchschnittliche Streams in anderen Jahreszeiten
mean_streams_other_seasons <- mean(dataset$streams[dataset$released_month %in% c(1, 2, 3, 4, 5, 9, 10, 11, 12)])

# Vergleich der beiden Werte
mean_streams_summer / mean_streams_other_seasons
  
mean_streams_summer
mean_streams_other_seasons

# Daten für das Balkendiagramm vorbereiten
bar_data <- data.frame(
  Season = c("Summer", "Other Seasons"),
  Mean_Streams = c(mean_streams_summer, mean_streams_other_seasons)
)

#Durschschnittliche Streams über die verschiedenen Monate berechnen
mean_streams_january <- mean(dataset$streams[dataset$released_month %in% c(1)])
mean_streams_february <- mean(dataset$streams[dataset$released_month %in% c(2)])
mean_streams_march <- mean(dataset$streams[dataset$released_month %in% c(3)])
mean_streams_april <- mean(dataset$streams[dataset$released_month %in% c(4)])
mean_streams_may <- mean(dataset$streams[dataset$released_month %in% c(5)])
mean_streams_june <- mean(dataset$streams[dataset$released_month %in% c(6)])
mean_streams_july <- mean(dataset$streams[dataset$released_month %in% c(7)])
mean_streams_august <- mean(dataset$streams[dataset$released_month %in% c(8)])
mean_streams_september <- mean(dataset$streams[dataset$released_month %in% c(9)])
mean_streams_october <- mean(dataset$streams[dataset$released_month %in% c(10)])
mean_streams_november <- mean(dataset$streams[dataset$released_month %in% c(11)])
mean_streams_dezember <- mean(dataset$streams[dataset$released_month %in% c(12)])


# Balkendiagramm erstellen

ggplot(bar_data, aes(x = Season, y = Mean_Streams, fill = Season)) +
  geom_bar(stat = "identity", position = "dodge", width = 0.7, color = "black") +
  labs(title = "Durchschnittliche Streamzahlen im Sommer vs. andere Jahreszeiten",
       x = "Jahreszeit",
       y = "Durchschnittliche Streams") +
  theme_minimal()

#Balkendiagramm für die Streamzahlen über die verschiedenen Monate

# Daten für das Balkendiagramm vorbereiten und chronologisch ordnen
bar_data_months <- data.frame(
  Month = c("January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "Dezember"),
  Mean_Streams = c(mean_streams_january, mean_streams_february, mean_streams_march, mean_streams_april, mean_streams_may, mean_streams_june, mean_streams_july, mean_streams_august, mean_streams_september, mean_streams_october, mean_streams_november, mean_streams_dezember)
)

#chronologische Ordnung der Daten
bar_data_months$Month <- factor(bar_data_months$Month, levels = c("January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "Dezember"))

#Balkendiagramm erstellen
ggplot(bar_data_months, aes(x = Month, y = Mean_Streams, fill = Month)) +
  geom_bar(stat = "identity", position = "dodge", width = 0.7, color = "black") +
  labs(title = "Durchschnittliche Streamzahlen über die verschiedenen Monate",
       x = "Monat",
       y = "Durchschnittliche Streams") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_y_continuous(labels = scales::comma)

```


### 4.2 Je beliebter ein Song ist, desto besser lässt sich zu ihm Tanzen lineare regression mit zwei werten

Es wird in diesem Fall für beide Werte eine lineare Regression durchgeführt, um zu sehen, ob es einen Zusammenhang zwischen den beiden Werten gibt. 

```{r}
# Lineare Regression durchführen
linear_regression <- lm(dataset$popularity_score ~ dataset$danceability_percent)

# Lineare Regression plotten
plot(dataset$danceability_percent, dataset$popularity_score, xlab = "Tanzbarkeit", ylab = "Beliebtheitsscore", main = "Lineare Regression zwischen Tanzbarkeit und Beliebtheit")
abline(linear_regression, col = "red")

# Lineare Regression auswerten
summary(linear_regression)

```
Aus der linearen Regression lässt sich nicht kein Zusammenhang zwischen den beiden Werten erkennen. Dies wird auch durch den Korrelationskoeffizienten bestätigt, der nahezu 0 ist.



# 5 Machine Learning Modelle


### 5.1 

z-Standardisieren

```{r}
cols_to_scale <- colnames(dataset |>  dplyr::select(popularity_score))
dataset_scale <- dataset |> mutate_at(cols_to_scale, ~(scale(.) |>  as.vector()))
```

Aufteilung in Trainings- und Testset

```{r}
set.seed(123)
dataset_split <- initial_split(dataset_scale, prop = 0.8, strata = popularity_score)
dataset_train <- training(dataset_split)
dataset_test  <- testing(dataset_split)
```

Modell initialisieren:

```{r}
mlp_dataset_mod <- 
    mlp() |>  
    set_mode("regression") |> 
    set_engine("nnet")
```

Modell trainieren:
```{r}
mlp_dataset_fit <- 
    mlp_dataset_mod |> 
    fit(popularity_score ~ ., data = dataset_train)
```

Vorhersage auf den Testdaten:
```{r}
pred <- predict(mlp_dataset_fit, dataset_test)
results <- dataset_test |>  dplyr::select(popularity_score) %>% bind_cols(pred)
```

```{r}
rmse(data = results, truth = popularity_score, estimate = .pred)
```





